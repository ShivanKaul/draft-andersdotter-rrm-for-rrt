<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Randomized Response Mechanisms in RRT Measurements for HTTP/3</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Randomized Response Mechanisms">
<link href="#rfc.section.3" rel="Chapter" title="3 Application to Spin Bit">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Case 1: RRM at reflection/inversion">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Analysis: No reset and no edge identifying bit">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Analysis: Reset and no edge identifying bit">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Analysis: An edge identifying bit">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 Discussion: Reflection/inversion">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 RRM at each bit">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Analysis: Estimating true values of a bit, client perturbation">
<link href="#rfc.section.4" rel="Chapter" title="4 Conclusion">
<link href="#rfc.references" rel="Chapter" title="5 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.24.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Andersdotter, A. and S. Sahib" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-andersdotter-rrm-for-rrt-in-http3-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-10-29" />
  <meta name="dct.abstract" content="The Latency Spin Bit is an optional feature included in Section 17.3.1. It enables passive latency monitoring from observations made on the network path throughout the duration of a connection. This draft presents the results of an inquiry into the potential of using randomized response mechanism (RRM) to enhance privacy gain in latency measurements. It concludes that RRM could be used to introduce choice for web browser clients in preserving privacy in latency measurements, but only at the cost of losing the utility of the latency measurements." />
  <meta name="description" content="The Latency Spin Bit is an optional feature included in Section 17.3.1. It enables passive latency monitoring from observations made on the network path throughout the duration of a connection. This draft presents the results of an inquiry into the potential of using randomized response mechanism (RRM) to enhance privacy gain in latency measurements. It concludes that RRM could be used to introduce choice for web browser clients in preserving privacy in latency measurements, but only at the cost of losing the utility of the latency measurements." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Research Task Force</td>
<td class="right">A. Andersdotter</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ARTICLE 19</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">S. Sahib</td>
</tr>
<tr>
<td class="left">Expires: May 1, 2020</td>
<td class="right">Salesforce</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 29, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Randomized Response Mechanisms in RRT Measurements for HTTP/3<br />
  <span class="filename">draft-andersdotter-rrm-for-rrt-in-http3-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Latency Spin Bit is an optional feature included in <a href="#I-D-QUIC" class="xref">Section 17.3.1</a>. It enables passive latency monitoring from observations made on the network path throughout the duration of a connection. This draft presents the results of an inquiry into the potential of using randomized response mechanism (RRM) to enhance privacy gain in latency measurements. It concludes that RRM could be used to introduce choice for web browser clients in preserving privacy in latency measurements, but only at the cost of losing the utility of the latency measurements.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 1, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Randomized Response Mechanisms</a>
</li>
<li>3.   <a href="#rfc.section.3">Application to Spin Bit</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Case 1: RRM at reflection/inversion</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Analysis: No reset and no edge identifying bit</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Analysis: Reset and no edge identifying bit</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Analysis: An edge identifying bit</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">Discussion: Reflection/inversion</a>
</li>
</ul><li>3.2.   <a href="#rfc.section.3.2">RRM at each bit</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Analysis: Estimating true values of a bit, client perturbation</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Conclusion</a>
</li>
<li>5.   <a href="#rfc.references">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">At the IETF104 convening of the Privacy Enhancements and (PEA) Research Group, a presentation on Differential Privacy (<a href="#AA-CL" class="xref">[AA-CL]</a>) gave rise to the idea of trying to apply Randomized Response methods to the QUIC Spin Bit described in <a href="#TRAMMEL" class="xref">[TRAMMEL]</a> and <a href="#KUEHLEWIND" class="xref">[KUEHLEWIND]</a>. The QUIC Spin Bit had generated controversy from a privacy perspective, both in the Working Group meetings and on e-mailing lists and been re-ignited through the publication of a subsequent Human Rights Consideration in <a href="#TENOEVER-MARTINI" class="xref">[TENOEVER-MARTINI]</a>.  </p>
<p id="rfc.section.1.p.2">Randomized response trials were originally created for binary environments: if a series of measurements has only two possible outcomes (0 or 1, yes or no, true or false, for instance), it is the idea that allowing individual respondents to answer "falsely" at a predictable rate will still preserve the ability to make inferences on the entire set of respondents. The Spin Bit, being a bit, is binary outcome variable. Each time it is measured, the idea is that it can either "truthfully" report its value as what it should be according to <a href="#TRAMMEL" class="xref">[TRAMMEL]</a>, or it could, at some known rate or probability, report the opposite value.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#rrt" id="rrt">Randomized Response Mechanisms</a>
</h1>
<p id="rfc.section.2.p.1">Randomized Response Mechanisms (RRM) rely on the ability to make sense of data with known errors and were originally developed to facilitate surveys on sensitive topics such as alcohol or drug abuse, or political affiliation. The design allows a survey taker to provide, with some known probability P, a "false" answer ("yes" instead of "no", for example) to a survey question. It is meant to encourage truthful answers even in surveys where participants may otherwise feel compelled to give false answers.</p>
<p id="rfc.section.2.p.2">RRMs are most easily illustrated for binary response problems. Let's take as an example "Did you go to the last IETF meeting?" The answer to this question is either yes or no. If 30% of all responses are known to be false, we have four categories of responses: true yes, true no, false yes and false no. From these numbers we can estimate the proportion of recurring visitors to the IETF.</p>
<p id="rfc.section.2.p.3">RRMs can also be applied to multiple choice questions. Estimation of true proportions becomes more difficult as the number of possible answers per question goes up. Further examples, including formulas and calculations, can be found in <a href="#DWORK" class="xref">[DWORK]</a> and <a href="#FOX" class="xref">[FOX]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#asb" id="asb">Application to Spin Bit</a>
</h1>
<p id="rfc.section.3.p.1">As described in <a href="#TRAMMEL" class="xref">[TRAMMEL]</a>, the Spin Bit is a mechanism for measuring round-trip-times (RTT) in the QUIC protocol. Its operation is captured by the following five images, extracted from this draft:</p>
<p id="rfc.section.3.p.2">Initially, during connection establishment, no packets with a spin bit are in flight, as shown in <a href="#illus0" class="xref">Figure 1</a>.</p>
<div id="rfc.figure.1"></div>
<div id="illus0"></div>
<pre>
+--------+   -  -  -  -  -   +--------+
|        |     --------&gt;     |        |
| Client |                   | Server |
|        |     &lt;--------     |        |
+--------+   -  -  -  -  -   +--------+
</pre>
<p class="figure">Figure 1: Initial state, no spin bit between client and server</p>
<p id="rfc.section.3.p.3">Either the server, the client, or both can begin sending packets with short headers after connection establishment, as shown in <a href="#illus1" class="xref">Figure 2</a>; here, no spin edges are yet in transit.</p>
<div id="rfc.figure.2"></div>
<div id="illus1"></div>
<pre>
+--------+   0  0  -  -  -   +--------+
|        |     --------&gt;     |        |
| Client |                   | Server |
|        |     &lt;--------     |        |
+--------+   -  -  0  0  0   +--------+
</pre>
<p class="figure">Figure 2: Client and server begin sending packets with spin 0</p>
<p id="rfc.section.3.p.4">Once the server&#8217;s first 0-marked packet arrives at the client, the client sets its spin value to 1, and begins sending packets with the spin bit set, as shown in <a href="#illus2" class="xref">Figure 3</a>. The spin edge is now in transit toward the server.</p>
<div id="rfc.figure.3"></div>
<div id="illus2"></div>
<pre>
+--------+   1  0  0  0  0   +--------+
|        |     --------&gt;     |        |
| Client |                   | Server |
|        |     &lt;--------     |        |
+--------+   0  0  0  0  0   +--------+
</pre>
<p class="figure">Figure 3: The bit begins spinning</p>
<p id="rfc.section.3.p.5">Five ticks later, this packet arrives at the server, which takes its spin value from it and reflects that value back on the next packet it sends, as shown in <a href="#illus3" class="xref">Figure 4</a>. The spin edge is now in transit toward the client.</p>
<div id="rfc.figure.4"></div>
<div id="illus3"></div>
<pre>
+--------+   1  1  1  1  1   +--------+
|        |     --------&gt;     |        |
| Client |                   | Server |
|        |     &lt;--------     |        |
+--------+   0  0  0  0  1   +--------+
</pre>
<p class="figure">Figure 4: Server reflects the spin edge</p>
<p id="rfc.section.3.p.6">Five ticks later, the 1-marked packet arrives at the client, which inverts its spin value and sends the inverted value on the next packet it sends, as shown in <a href="#illus4" class="xref">Figure 5</a>.</p>
<div id="rfc.figure.5"></div>
<div id="illus4"></div>
<pre>
      obs. points  X  Y
+--------+   0  1  1  1  1   +--------+
|        |     --------&gt;     |        |
| Client |                   | Server |
|        |     &lt;--------     |        |
+--------+   1  1  1  1  1   +--------+
                      Y
</pre>
<p class="figure">Figure 5: Client inverts the spin edge</p>
<p id="rfc.section.3.p.7">In each iteration of <a href="#illus3" class="xref">Figure 4</a>-<a href="#illus4" class="xref">Figure 5</a> the a sequence of 0s or 1s the length of which is k0 for iteration 0, k1 for iteration 1, and so forth, can be measured (by X or Y in the picture). The length of each sequence equals the amount of ticks required to pass from the client back to the client. After n iterations, an average can be taken of the measurements (k0, ..., kn). This average can be multiplied by the amount of time per tick (a quantity which is assumed to be known) to get a value for the round-trip time (RTT).</p>
<p id="rfc.section.3.p.8">Applying randomized response mechanisms (RRMs) perturbs the measurements (k0, ..., kn). The perturbation will have the effect of lengthening, shortening, or making more arbitrary the size of the measurement, thereby increasing the variance, or disable the possibility, of an estimator of the true RTT value.</p>
<p id="rfc.section.3.p.9">The server or the client is assumed to always behave as described in <a href="#illus3" class="xref">Figure 4</a>-<a href="#illus4" class="xref">Figure 5</a> with no RRM. That means the assumed default behaviour is that a "truly" reflecting server that receives a bit set to v=0 always reflects a bit with v=0, while a server which "falsely" reflects a bit receives a bit set to v=0 and reflects a bit set to v=1. Different probabilities could be applied to the server and client, respectively, transmitting a "wrong" value or delaying a reflection.</p>
<p id="rfc.section.3.p.10">An additional assumption is that the server and client behave independently of one another. This means that the server has no information on whether the client has omitted an inversion, and the client has no information on whether the server has omitted a reflection. Omissions are therefore independent events.</p>
<p id="rfc.section.3.p.11">We have looked at three ways of perturbing measurements:</p>
<p></p>

<ul class="empty">
<li>1. RRMs are applied so that the reflections in <a href="#illus3" class="xref">Figure 4</a> or inversions in <a href="#illus4" class="xref">Figure 5</a> do not occur with probability P or Q respectively.</li>
<li>2. RRMs are applied so that that each bit transmitted from the client, whether or not an inversion is occurring, has a probability P of being the "wrong" value.</li>
<li>3. RRMs are applied so that that each bit transmitted from the server, whether or not a reflection is occurring, has a probability Q of being the "wrong" value.</li>
</ul>

<p> </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#reflection" id="reflection">Case 1: RRM at reflection/inversion</a>
</h1>
<p id="rfc.section.3.1.p.1">The omission of a reflection or inversion creates difficulties. Namely, let's say the client omits the inversion in <a href="#illus4" class="xref">Figure 5</a>. Now there is no longer a spin edge so there is nothing to activate future reflections/inversions.</p>
<p id="rfc.section.3.1.p.2">A possible work-around is to do random re-sets of the spin bit, i.e., starting the process fresh from <a href="#illus1" class="xref">Figure 2</a>. Observers X and Y in <a href="#illus4" class="xref">Figure 5</a> would then get a series of measurements (k0, ..., kn), some of which were far too large, but would, over time, be able to deduce RTT from the smaller measurements. The expected proportion of large and small measurements in the whole set of measurements could be determined from the probabilities that a reflection/inversion does not happen and the probability that the spin bit is re-initiated.</p>
<p id="rfc.section.3.1.p.3">Another possible work-around is having an additional bit to indicate a spin edge, assigned by the server to the bit which is (not) reflected in <a href="#illus3" class="xref">Figure 4</a>, or by the client to the bit which is (not) inverted in <a href="#illus4" class="xref">Figure 5</a>. In this case there would not be a point in applying RRM since the placement of the spin edge would no longer be obfuscated.</p>
<p id="rfc.section.3.1.p.4">If the ordinary spin edge is obfuscated by through omission of reflection/inversion, and the edge-identifying bit is also, with some probability, not correctly identifying an edge, the utility of having two latency bits again goes up at no additional loss of privacy.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#example1" id="example1">Analysis: No reset and no edge identifying bit</a>
</h1>
<p id="rfc.section.3.1.1.p.1">The bit starts spinning with value v=1 in <a href="#illus2" class="xref">Figure 3</a>. At the point of reflection (see <a href="#illus3" class="xref">Figure 4</a>), it does not reflect with probability P. At the point of inversion (see <a href="#illus4" class="xref">Figure 5</a>), it does not invert with probability Q. We consider P and Q respectively to be the probability that the server or client does not behave in the way specified.</p>
<p id="rfc.section.3.1.1.p.2">Let -&gt; be the operation that a bit changes value. A correct reflection will be denoted R: a-&gt;a. A correct inversion is denoted I:a-&gt;b. Prefixing R or I with a ! denotes that reflection/inversion was not done correctly. The variables a and b assume the values 0 or 1 and are never equal. P(R: a-&gt;a) = 1-P and P(I: a-&gt;b) = 1-Q, while P(!R: a-&gt;b) = P and P(!I: a-&gt;a) = Q. An expression like R(v: 1-&gt;1) -&gt; !I(v: 1-&gt;1) means that a bit whose initial value is 1 is correctly reflected, and then incorrectly inverted. We can abbreviate this to [1-&gt;1-&gt;1]. R must follow I and vice versa, so we will have a chain of events R-&gt;I-&gt;R-&gt;I-&gt; etc.</p>
<p id="rfc.section.3.1.1.p.3">In order for a reflection or an inversion to occur, there must be a trigger. The spin edge is the trigger. But in the event of [1-&gt;1-&gt;1] the spin edge has disappeared! Once the bit spins back to the reflection, it will have the same value as when it started. In fact, regardless of the starting value, any R-&gt;I event that results in [1-&gt;1] or [0-&gt;0] leads to a loop.</p>
<p id="rfc.section.3.1.1.p.4">We can define the following events:</p>
<p></p>

<ul class="empty">
<li>A: [1-&gt;1].  </li>
<li>B: [0-&gt;0].  </li>
<li>C: [0-&gt;1].  </li>
<li>D: [1-&gt;0].  </li>
</ul>
<p id="rfc.section.3.1.1.p.6">Event A can occur as a result of (!R, !I) for starting point v=0, or as a result of (R, !I) for starting point v=1 or v=0. Event B can occur as a result of (!R, !I) for starting point v=1, or as a result of (R, !I) for starting point v=1 or v=0. Event C occurs as a result of (!R, I) for starting point v=1, or (R, I) for starting point v=0. Event D occurs as a result of (!R, I) for starting point v=0 or (R, I) for starting point v=0. The starting point v can be taken as the final digit in each event, meaning that for the event following C, the starting point would be v=1, and for the event following D, the starting point would be v=0.</p>
<p id="rfc.section.3.1.1.p.7">With this information, and the probabilities determined above, we can create a transition matrix in the Markovian sense.</p>
<div id="rfc.figure.6"></div>
<div id="illus6"></div>
<pre>

+----+-----------+-----------+-----------+-----------+
|    |     A     |     B     |     C     |     D     |
+----+-----------+-----------+-----------+-----------+
| A  |     1     |     0     |     0     |     0     |
+----+-----------+-----------+-----------+-----------+
| B  |     0     |     1     |     0     |     0     |
+----+-----------+-----------+-----------+-----------+
| C  |  (1-P)Q   |     Q     |   P(1-Q)  | (1-P)(1-Q)|
+----+-----------+-----------+-----------+-----------+
| D  |     Q     |  (1-P)Q   |(1-P)(1-Q) |  P(1-Q)   |
+----+-----------+-----------+-----------+-----------+
</pre>
<p class="figure">Figure 6: RRM transition matrix, no reset and no edge-id bit</p>
<p id="rfc.section.3.1.1.p.8">It should be quite clear from this matrix that events A and B act as sinks. Because ending in a sink removes all possibility of future measurements, we could hope to avoid this situation. The easiest way is setting Q=0, which would imply there is always a correct inversion. For any Q &gt; 0, this process will eventually end up in a sink.</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#example2" id="example2">Analysis: Reset and no edge identifying bit</a>
</h1>
<p id="rfc.section.3.1.2.p.1">The possible outcomes are as in <a href="#example1" class="xref">Section 3.1.1</a>, and the problem to be resolved is that the spin edge eventually disappears with probability 1.</p>
<p id="rfc.section.3.1.2.p.2">Introducing the probability R of a random re-set of the spin bit at every m:th bit transmission can "re-initiate" the edge by taking the entire system back into the situation described in <a href="#illus3" class="xref">Figure 4</a> (with the modification that it is not assumed that the starting point must be v=1; the starting point could also be reset to v=0). It is assumed that a re-set occurs on the client-side, and not on the server-side.</p>
<p id="rfc.section.3.1.2.p.3">The true number of ticks in a round-trip time is C. If R&gt;0 and m &gt;&gt; C, the process will be reset every period of km ticks, where k is an integer whose distribution is geometric with parameter R. After km ticks, an on-path observer may pick up a sequence that can be used as a basis for measuring the round-trip time.</p>
<p id="rfc.section.3.1.2.p.4">In <a href="#illus7" class="xref">Figure 7</a> the situation where m=2 is illustrated.</p>
<div id="rfc.figure.7"></div>
<div id="illus7"></div>
<pre>

+---+----------+--------+----------+--------+----------+----------+
|   |   A,m0   |  A,m1  |   B,m0   |   B,m1 |    C     |     D    |
+---+----------+--------+----------+--------+----------+----------+
|A,0|     0    |   1    |    0     |    0   |    0     |     0    |
+---+----------+--------+----------+--------+----------+----------+
|A,1|    1-R   |   0    |    0     |    0   |    R     |     0    |
+---+----------+--------+----------+--------+----------+----------+
|B,0|     0    |   0    |    0     |    1   |    0     |     0    |
+---+----------+--------+----------+--------+----------+----------+
|B,1|     0    |   0    |   1-R    |    0   |    R     |     0    |
+---+----------+--------+----------+--------+----------+----------+
| C |  (1-P)Q  |   0    |    Q     |    0   |  P(1-Q)  |(1-P)(1-Q)|
+---+----------+--------+----------+--------+----------+----------+
| D |     Q    |   0    |  (1-P)Q  |    0   |(1-P)(1-Q)|  P(1-Q)  |
+---+----------+--------+----------+--------+----------+----------+
</pre>
<p class="figure">Figure 7: RRM TM, Reset at m=2, no edge-id bit</p>
<p id="rfc.section.3.1.2.p.5">If m (or km | k ~ Ge(R)) is too small, there will never be any sound measurements since the process will always start over before a measurement appears. Using a reset function is therefore especially burdensome for an on-path observer in cases where latencies are a priori expected to be large.</p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#example3" id="example3">Analysis: An edge identifying bit</a>
</h1>
<p id="rfc.section.3.1.3.p.1">The possible outcomes are as in <a href="#example1" class="xref">Section 3.1.1</a>, and the problem to be resolved is that the spin edge eventually disappears with probability 1.</p>
<p id="rfc.section.3.1.3.p.2">Introducing an edge identifying bit, which may or may not hold a true value with probability S, could help mitigate this problem. This could effectively be seen as a recursive RRM: because the original RRM risks removing the utility of the spin bit entirely, another bit to which RRM is applied is added.</p>
<p id="rfc.section.3.1.3.p.3">Logically, adding another identifying bit increases the possible set of states of the Markovian chains described in <a href="#example1" class="xref">Section 3.1.1</a> and <a href="#example2" class="xref">Section 3.1.2</a>. In fact, the systems would still possess similar short-comings, but with different probabilities. The exception is if the identifying bit is always on with probability S=1. In this case, the privacy-enhancing properties sought in <a href="#example1" class="xref">Section 3.1.1</a> and <a href="#example2" class="xref">Section 3.1.2</a> would be lost, since the main goal of RRM in both of those cases is to perturb the measurements (k0, ...., kn) used to estimate round-trip times.</p>
<h1 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#discussion1" id="discussion1">Discussion: Reflection/inversion</a>
</h1>
<p id="rfc.section.3.1.4.p.1">In <a href="#example1" class="xref">Section 3.1.1</a> we saw that applying RRM at reflection and inversion could create a situation where the spin edge disappears. There are two parameters, P and Q, which are set by the client and server respectively.</p>
<p id="rfc.section.3.1.4.p.2">We could reduce the risk of the spin edge disappearing by setting the probability of a wrongful inversion to Q=0. However, inversion is an activity undertaken by the client and Q is a parameter under the clients control. Since the client is the entity assumed, in most cases, to be the most likely actor to be a human, natural person (in either case, more likely than the server), this solution would remove power from the client. Forcibly setting Q=0 would violate the assumptions of user control in <a href="#RFC6973" class="xref">Section 7.2</a>.</p>
<p id="rfc.section.3.1.4.p.3">In <a href="#example2" class="xref">Section 3.1.2</a> we considered whether it was possible to reset a latency spin bit whose edge has disappeared. Effectively, resetting would improve an on-path observers chances of making measurements, but it also introduces a delay for the acquisition of useful measurements.</p>
<p id="rfc.section.3.1.4.p.4">We assume that the client will set Q&gt;0 and that this is under the client's control, and have three additional parameters: P, m and R. Both m and R can be under the client's control. We found that km | k~Ge(R) has an impact on the ability to measure latency when latency is large. In practice, an average human, natural person is probably not going to choose parameters Q, m and R (even though they could be made available at settings in an interface). Setting of these parameters will instead likely be under the control of the entity that produces latency spin bit capable software.</p>
<p id="rfc.section.3.1.4.p.5">In  <a href="#example3" class="xref">Section 3.1.3</a> we conclude that adding an edge-identifying bit is not a remedy to any of the issues with the methods in  <a href="#example1" class="xref">Section 3.1.1</a> or  <a href="#example2" class="xref">Section 3.1.2</a>. It introduces the possibility of yet another client-controlled parameter S, but the obfuscating effects derived from S could instead be obtained by regulating previously suggested parameters Q, m or R.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#eachbit" id="eachbit">RRM at each bit</a>
</h1>
<p id="rfc.section.3.2.p.1">Let us say any bit transmitted from either the client or the server is "off" in relation to what it proposed in the Spin Bit model with some probability Q. If Q = 0.5, the spinning bits will come across as a random 0s and 1s and it will be difficult to estimate any edge. However, if Q is less than 0.5, the spin edge can be estimated for instance by computing an average number of 0s or 1s in the past m ticks. For all averages above some cut-off rate, a measurement counter could be incremented by one. Eventually one would end up with a series (k'0, ..., k'n) that roughly corresponds to (k0, ..., kn) above.</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#example4" id="example4">Analysis: Estimating true values of a bit, client perturbation</a>
</h1>
<p id="rfc.section.3.2.1.p.1">The bit spins in the foreseen way. Every time a bit is transmitted, there is a probability Q that it holds a different value than it should. In <a href="#illus4" class="xref">Figure 5</a> , either measurements station X or both stations Y observe a passing bit, as well as bits passing before or after that bit (if any). After observing 2k+1 bits (b[-k], ..., b[0], ..., b[k]) the true value of bit b[0] is estimated, for instance based on whether the majority of b[i] were v=0 or v=1. The estimated value is then used to increment a sequence counter.</p>
<p id="rfc.section.3.2.1.p.2">The estimator follows a binomial distribution (drawing with replacement), and the risk of misidentifying a bit is equal to the risk of having (k+1) v=1 bits in the 2k observations where b[0] "should" be attributed to v=0. This risk depends on Q and k.</p>
<p id="rfc.section.3.2.1.p.3">Setting k too large creates a risk of having estimator sequences that are longer than the round-trip time (RTT) to be measured. If Q is reasonably small, estimation will still eventually be possible after a sufficient amount of measurements. One option is to keep Q variable and determined by the client, introducing the possibility of choice in RTT measurements.</p>
<p id="rfc.section.3.2.1.p.4">Make the following assumptions:</p>
<p></p>

<ul class="empty">
<li>1. the "real" round-trip time is 6+7=13, where 6 is the number of ticks between the client and server, and 7 is the number of ticks between server and client.</li>
<li>2. the server always reflects exactly the value of the bit it receives, and</li>
<li>3. the client always inverts the value of the bit it receives, meaning that all spin edges are always preserved.</li>
</ul>
<p id="rfc.section.3.2.1.p.6">Four RTTs of the spin bit according to specification would now give rise to the following data, available to an on-path observer: 0000000000000111111111111100000000000001111111111111. To estimate the time of a RTT, we could compute 13*4/4 = 13 time units.</p>
<p id="rfc.section.3.2.1.p.7">Set Q=0.2. Now the four RTTs may instead be measured as 1001000000100111111001111100000010010110111011010111. With this sequence, we would instead estimate (1+2+1+6+1+2+6+2+5+6+1+2+ 1+1+2+1+3+1+2+1+1+1+3)/23 = 2.26. That is clearly not satisfactory if the target round-trip time estimation is 13.</p>
<p id="rfc.section.3.2.1.p.8">Divide the RTT measurements into moving windows with k=2 (i.e., each window contains (b[-2], b[-1], b[0], b[1], b[2])) to arrive at [(10010), (00100), (01000), (10000), (00000), (00000), (00001), (00010), (00100), etc]. Each window estimates b[0], so the "true" value of bit 2 will be estimated by (10010), the true value of bit three from (00100), and so forth.</p>
<p id="rfc.section.3.2.1.p.9">Applying the procedure we are left with 000000000011111111111111000000000011111111111111, or (10+14+14+10)/4=12. This is much better precision if the target round-trip time estimation is 13.</p>
<h1 id="rfc.section.3.2.1.1">
<a href="#rfc.section.3.2.1.1">3.2.1.1.</a> <a href="#example5" id="example5">Analysis: Estimating true values of a bit, client and server perturbation</a>
</h1>
<p id="rfc.section.3.2.1.1.p.1">Now let us consider the case where both the client and server randomize each transmitted bit, with probabilities Q and P respectively. Using the same assumptions as in <a href="#example4" class="xref">Section 3.2.1</a> and the same target RTT of 13, and letting Q=0.2 and P=0.1, we may end up measuring 0000000000000111111111011100000001010001111010011111 and throw the method of moving windows for k=2 arriving at 000000000001111111111111000000000000011111001111 leaving us with sequences of length (11, 13, 13, 5, 2, 4).</p>
<p id="rfc.section.3.2.1.1.p.2">As previously mentioned, the risk of a bit being misidentified is related to P, Q and k. Because a misidentified bit always make sequences appear to be of shorter length, the sequences that measure greater length should be taken as the RTT estimate. In this event that we choose to only use that half of the esimated sequences with the greatest length as a basis for the latency calculations, we would have (11+13+13)/3=12.3 as the estimator for the RTT.</p>
<h1 id="rfc.section.3.2.1.2">
<a href="#rfc.section.3.2.1.2">3.2.1.2.</a> <a href="#discussion2" id="discussion2">Discussion: RRM at each bit</a>
</h1>
<p id="rfc.section.3.2.1.2.p.1">In the introduction to this section, we observed that setting Q=0.5 would make any pattern recognition among the bits extremely difficult for the most advanced of filters. We proceeded to discuss the case Q=0.2 and a potential filter for this case in <a href="#example4" class="xref">Section 3.2.1</a>. If Q is taken to be a parameter under client control, of course the client could set Q so that latency measurements are made impossible. On the other hand, such client control already exists, since the latency spin bit is optional. (see <a href="#RFC6973" class="xref">Sec. 7.2</a> and <a href="#I-D-QUIC" class="xref">Section 17.3.1</a>). </p>
<p id="rfc.section.3.2.1.2.p.2">In <a href="#example5" class="xref">Section 3.2.1.1</a> we introduced the possiblity of yet another parameter P, to be set by the server for determining server-side RRM application. The moving windows filtering method applied to make sense of on-path observations remains the same.</p>
<p id="rfc.section.3.2.1.2.p.3">The filtering methods applied in this section consistently under-estimate the true latency. More accurate latency measurements may be achieved by having a larger number of sequences observed.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#conclusion" id="conclusion">Conclusion</a>
</h1>
<p id="rfc.section.4.p.1">The spin bit is associated with an IP address which creates linkability (see <a href="#RFC6973" class="xref">[RFC6973]</a> and <a href="#RFC8280" class="xref">[RFC8280]</a>). The privacy concern associated with a spin bit is, additionally, that latency measurements will enable inferrence of the location or distance of the device associated with that particular IP address.</p>
<p id="rfc.section.4.p.2">In <a href="#example1" class="xref">Section 3.1.1</a>, it was seen Randomized response mechanisms (RRM) would either cause the utility of the spin bit to disappear entirely (by rendering any measurement futile) or cause the primary privacy-reducing inferrence to remain a problem, as long as a sufficiently large amount sequential measurements were done. Each measurement would continue to be tied to fixed identifier, which necessarily implies privacy loss. Interestingly, <a href="#example1" class="xref">Section 3.1.1</a> also highlights fundamental trade-offs between privacy-preserving mechanisms and measurement utility: by setting Q=0, we were able to avoid ending up in a sink, which would improve the possibility of measurement, but in doing so removed all agency from the client to falsify its responses.</p>
<p id="rfc.section.4.p.3">In <a href="#example4" class="xref">Section 3.2.1</a> we saw that setting Q=0.5 could obfuscate the spin edge from an on-path observer. Since the latency spin bit is an optional feature, an easier method of accomplishing such obfuscation would be to simply to turn the spin bit off. Setting Q &lt; 0.5 would instead let the client make it easier or more difficult for the on-path observer to correctly estimate latency. In <a href="#example4" class="xref">Section 3.2.1</a> and <a href="#example5" class="xref">Section 3.2.1.1</a> we particularly conclude that under-estimation of latency is the most likely outcome of this RRM.</p>
<p id="rfc.section.4.p.4">It is not clear that RRM would ultimately bring any particular privacy benefit beyond what is already guaranteed in the present specification of the spin bit in <a href="#I-D-QUIC" class="xref">Section 17.3.1</a>. A possible option is to allow a client to set a randomization value P in such a way that it could be close to 0.5, in the case where each bit is always RRM-protected. Then the client would have the option of avoiding latency measurements entirely.</p>
<h1 id="rfc.references">
<a href="#rfc.references">5.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="AA-CL">[AA-CL]</b></td>
<td class="top">
<a>Andersdotter, A.</a> and <a>C. L&#229;ngstr&#246;m</a>, "<a href="https://datatracker.ietf.org/meeting/104/materials/slides-104-pearg-amelia-christoffer-differential-privacy-00">Differential Privacy (PEARG, IETF104)</a>", March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="DWORK">[DWORK]</b></td>
<td class="top">
<a>Roth, A.</a> and <a>C. Dwork</a>, "<a href="https://www.cis.upenn.edu/~aaroth/Papers/privacybook.pdf">The Algorithmic Foundations of Differential Privacy</a>", 2014.</td>
</tr>
<tr>
<td class="reference"><b id="FOX">[FOX]</b></td>
<td class="top">
<a>Fox, J.</a>, "<a>Randomized Response and Related Methods: Surveying Sensitive Data</a>", February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D-QUIC">[I-D-QUIC]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-23">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", September 2019.</td>
</tr>
<tr>
<td class="reference"><b id="KUEHLEWIND">[KUEHLEWIND]</b></td>
<td class="top">
<a>Kuehlewind, M.</a> and <a>B. Trammel</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-spin-exp-01">The QUIC Latency Spin Bit (draft-ietf-quic-spin-exp-01)</a>", October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6973">[RFC6973]</b></td>
<td class="top">
<a>Cooper, A.</a>, <a>Tschofenig, H.</a>, <a>Aboba, B.</a>, <a>Petersen, J.</a>, <a>Morris, J.</a>, <a>Hansen, M.</a> and <a>R. Smith</a>, "<a href="https://tools.ietf.org/html/rfc6973">Privacy Considerations for Internet Protocols</a>", RFC 6973, DOI 10.17487/RFC6973, July 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8280">[RFC8280]</b></td>
<td class="top">
<a>Ten Oever, N.</a> and <a>C. Cath</a>, "<a href="https://tools.ietf.org/html/rfc8280">Human Rights Considerations for Internet Protocols</a>", RFC 8280, DOI 10.17487/RFC8280, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TENOEVER-MARTINI">[TENOEVER-MARTINI]</b></td>
<td class="top">
<a>Martini, B.</a> and <a>N. Ten Oever</a>, "<a href="https://tools.ietf.org/html/draft-martini-hrpc-quichr-00">QUIC Human Rights Review (draft-martini-hrpc-quichr-00)</a>", October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="TRAMMEL">[TRAMMEL]</b></td>
<td class="top">
<a>Trammel, B.</a>, <a>Boucadair, M.</a>, <a>Even, R.</a>, <a>Fioccola, G.</a>, <a>Fossati, T.</a>, <a>Ihlar, M.</a>, <a>Morton, A.</a> and <a>E. Stephan</a>, "<a href="https://www.ietf.org/archive/id/draft-trammell-quic-spin-03.txt">Adding Explicit Passive Measurability of Two-Way Latency to the QUIC Transport Protocol (draft-trammell-quic-spin-03)</a>", May 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Amelia Andersdotter</span> 
	  <span class="n hidden">
		<span class="family-name">Andersdotter</span>
	  </span>
	</span>
	<span class="org vcardline">ARTICLE 19</span>
	<span class="adr">
	  <span class="vcardline">Free Word Centre, 60 Farringdon Road</span>

	  <span class="vcardline">
		<span class="locality">London EC1R 3GA</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:amelia@article19.org">amelia@article19.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Shivan Sahib</span> 
	  <span class="n hidden">
		<span class="family-name">Sahib</span>
	  </span>
	</span>
	<span class="org vcardline">Salesforce</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:shivankaulsahib@gmail.com">shivankaulsahib@gmail.com</a></span>

  </address>
</div>

</body>
</html>
